1
00:00:00,919 --> 00:00:54,320
xin chào, tôi là David Wong. Tôi là sinh viên thạc sĩ mật mã tại Đại học Bordeaux. Tôi hiện cũng là thực tập sinh tại Dịch vụ mật mã và video này sẽ giải thích về hai cuộc tấn công vào RSA sử dụng phương pháp giảm latis  kỹ thuật cuộc tấn công đầu tiên sẽ là cuộc tấn công của Copper Smith, người đầu tiên phát hiện ra rằng bạn có thể tấn công RSA bằng isis và sau đó chúng ta sẽ xem cách Grave Letter đơn giản hóa cuộc tấn công này như thế nào. Cuộc tấn công thứ hai là một cuộc tấn công giống như Smith được phát hiện bởi  Bon và Dery và đó cũng là bức thư được Herman và May đơn giản hóa, vì vậy trước tiên chúng ta hãy tự nhắc nhở bản thân một cách ngắn gọn RSA là gì để chúng ta cùng thống nhất RSA là một hệ thống mật mã khóa công khai được phát minh cách đây 30 năm và nó cho phép chúng ta mã hóa và ký tên.

2
00:00:54,320 --> 00:02:08,800
Tôi sẽ chỉ giải thích phần mã hóa vì việc ký kết gần như là một  thao tác nghịch đảo nên trước tiên để mã hóa bạn cần tạo khóa chung và khóa riêng. Liên kết với khóa chung, khóa chung bao gồm số mũ chung e và n lớn  mô-đun khóa riêng có cùng Big N, cùng một mô-đun và cũng có số mũ riêng  D để mã hóa tin nhắn M bạn chỉ cần lấy số của mình M bạn nâng nó lên lũy thừa của E số mũ công khai bạn lấy số đó theo modulo n và cho bạn văn bản mật mã và để giải mã văn bản mật mã đó, bạn làm tương tự nhưng với số mũ riêng thì điều này hiệu quả vì e và D  nghịch đảo lẫn nhau để tạo ra e và D trước tiên bạn cần tạo p và Q hai số nguyên tố và N mô đun sẽ là phép nhân của p và Q, thật dễ dàng tìm thấy D và E nhờ số nguyên tố PN q và đó là lý do tại sao chúng tôi nói rằng tính bảo mật của RSA được giảm xuống thành hệ số của n vì vậy nếu bạn có thể tìm thấy một trong các Prime bằng cách phân tích n chẳng hạn  thì về cơ bản bạn có thể tìm thấy khóa riêng nếu bạn chỉ có khóa chung.

3
00:02:08,800 --> 00:03:16,360
Có một số cách tấn công RSA và cũng có một số mục tiêu. Điều đầu tiên là phải biết bạn muốn gì, bạn muốn khôi phục văn bản pl hay bạn muốn khôi phục văn bản pl?  khóa riêng và nhân tiện, việc khôi phục khóa riêng được gọi là phá vỡ hoàn toàn vì nếu bạn khôi phục khóa riêng thì bạn có thể giải mã mọi thứ bạn muốn và bạn hoàn toàn phá vỡ hệ thống, bạn đã phá vỡ hoàn toàn hệ thống, các cuộc tấn công bạn có thể thấy trong tin tức và  các lỗ hổng thông thường đang được phát hiện thường được thực hiện trong phần triển khai của hệ thống mật mã vì tấn công toán học rất khó nhưng một số người, một số nhà nghiên cứu đã nghĩ tại sao không tấn công một  mô hình thoải mái hơn, ví dụ như mô hình mà chúng ta có quyền truy cập vào một bài báo cung cấp  cho chúng tôi một phần của thông điệp hoặc có thể chúng tôi biết giá trị gần đúng của một trong các số nguyên tố hoặc có thể số mũ riêng tư quá nhỏ và sau này tôi sẽ định nghĩa ý tôi là quá nhỏ và trong những mô hình thoải mái đó, các nhà nghiên cứu đã phát hiện ra rằng

4
00:03:16,360 --> 00:04:23,520
nó hơi nhỏ  dễ hơn, không dễ nhưng dễ hơn một chút khi tấn công toán học của U RSA vì vậy hãy để tôi giới thiệu ltis nếu bạn chưa biết nó là gì, nó khá đơn giản nếu bạn nghĩ về không gian Vector chẳng hạn ở bên trái bạn có  hai vectơ vì vậy đó là cơ sở của không gian Vector của chúng ta và bạn có thể thực hiện bất kỳ kết hợp tuyến tính nào của các vectơ đó để bạn có thể nhân chúng với các số vô hướng, giả sử là số thực và sau đó bạn có thể cộng các vectơ mới mà bạn đã nhân với nhau, ví dụ như bạn có thể lấy  Vector đầu tiên nhân với 3,7 và bạn cộng nó với vectơ thứ hai nhân với trừ1 và điều đó mang lại cho bạn một Vector khác vẫn nằm trong không gian vectơ và bạn có được không gian Vector liền kề này được tạo thành từ tất cả các kết hợp khác nhau của hai vectơ đó  Bây giờ các vectơ tưởng tượng rằng bạn không thể nhân chúng với Học giả với số thực và bạn chỉ có thể nhân chúng với số nguyên, điều đó có nghĩa là bạn vẫn có cơ sở giống nhau nhưng bạn chỉ có thể thực hiện theo U kết hợp tuyến tính trong

5
00:04:23,520 --> 00:05:34,880
các số nguyên mà nó cung cấp cho bạn một tập hợp  của các điểm trong không gian và đây là ltis, nó là một không gian rời rạc, có nghĩa là nếu bạn lấy bất kỳ điểm nào trong không gian đó, bạn sẽ có thể tìm thấy một hình cầu có tâm quanh điểm đó chỉ chứa điểm đó, điều này không thể thực hiện được trong uh a  Ví dụ, không gian số thực thực, vì vậy atis về cơ bản là thế này, nó là một không gian được kéo dài bởi sự kết hợp tuyến tính của một số vectơ nhưng trong các số nguyên và điều đó thật thú vị vì trong mật mã, chúng ta thường chơi với các số nguyên và chúng tôi muốn tìm một mô hình toán học  nó gần giống với những gì chúng tôi đang làm đúng và điều thú vị về ltis là chúng tôi có tất cả những công cụ đó, đặc biệt là công cụ được tạo ra bởi những người tự do có tên bắt đầu bằng chữ L nên nó được gọi là l l l và thuật toán này cho phép chúng tôi  để tìm một cơ sở nhỏ hơn nếu bạn có một nếu bạn cho nó một cơ sở của ltis thì trên đó bạn có lce này với hai vectơ giống như một cơ sở ngẫu nhiên hai

6
00:05:34,880 --> 00:06:52,160
vectơ và L làm điều đó là nó tìm thấy hai vectơ mới nhỏ hơn và trải dài trên cùng một mạng nên ltis không thay đổi nhưng cơ sở  ngắn hơn, sau đó chúng ta sẽ hiểu tại sao nó giúp ích cho chúng ta nhưng những ý tưởng cơ bản mà bạn cung cấp rằng cơ sở thuật toán đó mang lại cho bạn cơ sở mới với các vectơ ngắn hơn và bạn  có một công thức chính xác cho Bond trên của các vectơ mới đó và điều đó sẽ giúp chúng ta rất nhiều vì vậy cuộc tấn công đầu tiên chúng ta sẽ thấy là cuộc tấn công coer Smith coer Smith và anh ta là người đầu tiên sử dụng ltis để tấn công RSA nên anh ta đang nghĩ về  mô hình mô hình ban đầu trong đó bạn chỉ đang cố gắng tìm một tin nhắn từ văn bản Mật mã và khóa chung để bạn biết C bạn biết e bạn biết n nhưng bạn không biết M và bạn đang cố gắng tìm cái đó và cái đó khó cái đó rất khó vậy nếu bạn biết một phần của tin nhắn thì sao nếu tin nhắn đó luôn giống như mật khẩu ngày nay và mật khẩu sẽ có nghĩa là ở đây trong phương trình này bạn biết m0 nhưng bạn không biết x0  và bạn đang cố gắng tìm

7
00:06:52,160 --> 00:08:04,400
x0 và bạn có thể biến nó thành một phương trình nên việc hiểu cách bạn dịch nó thành một phương trình thực sự không quan trọng lắm nhưng nếu bạn muốn dành thời gian để hiểu thì bạn có thể tạm dừng video  và chỉ cần hiểu điều đó nhưng ý tưởng ở đây là coper Smith đưa ra một thuật toán để tìm nghiệm của một modulo đa thức n khi các nghiệm  đủ nhỏ và bằng cách tìm các nghiệm bạn sẽ tìm ra nghiệm của bài toán của chúng ta vì vậy hãy tìm nghiệm của một modulo đa thức  n khá là khó, chúng tôi thực sự không biết cách thực hiện nhưng nếu chúng tôi có một đa thức trên các số nguyên và có gốc của nó trên các số nguyên thì chúng tôi biết cách thực hiện, chúng tôi có các kỹ thuật cho việc đó, ví dụ như Hệ số  đa thức và chỉ đọc các nghiệm nhưng mod và không quá nhiều không dễ dàng nên ý tưởng đầu tiên của coper Smith là tìm một đa thức G khác ở đây có cùng nghiệm với bài toán F của chúng ta nhưng trên các số nguyên và sau đó sẽ dễ dàng  được rồi, vậy làm thế nào để chúng ta tìm được đa thức mới có cùng nghiệm nhưng trên

8
00:08:04,400 --> 00:09:26,800
các số nguyên hogra gr rằng uh đơn giản hóa cuộc tấn công vài năm sau đó mang lại cho chúng ta định lý tuyệt đẹp này vì vậy hãy tưởng tượng hãy tưởng tượng bạn có cái này G uh đa thức này mà  có nghiệm mà chúng ta đang tìm modulo n và chúng ta biết rằng nghiệm này đủ nhỏ, nó bị giới hạn trên bởi X lớn bên phải nên chúng ta biết B ở trên cho gốc này và hog gr cho chúng ta biết rằng nếu chúng ta có điểm thứ hai  phần thứ hai của đa thức đó phương trình này là chuẩn của một đa thức mới được tạo từ đa thức thứ nhất và giới hạn trên và nếu Chuẩn này bị giới hạn trên bởi một số cụ thể thì chúng ta biết rằng đa thức này có gốc từ các số nguyên và  vì vậy chúng ta có thể tính nghiệm của nó trên các số nguyên trong mô-đun n vì nó dễ hơn nên làm cách nào để chúng ta tìm ra loại đa thức đó. Ý tưởng ở đây là chúng ta có thể tạo ra một số đa thức có cùng Căn nguyên như bài toán F của chúng ta và kết hợp  họ sử dụng phép toán tuyến tính trên các số nguyên nên chúng tôi giữ nguyên các gốc nên chúng tôi có một

9
00:09:26,800 --> 00:10:39,279
nhóm Pol đang tạo ra một đa thức mới có cùng gốc và cái nào có hệ số nhỏ nên nếu bạn lấy chuẩn của đa thức mới này, bạn sẽ nhận được thứ gì đó  đủ nhỏ để nó bị giới hạn trên bởi điều này được thôi nhưng điều này thật khó vì chúng ta thực sự không biết cách tạo ra tất cả các pol có cùng gốc với vấn đề của chúng ta uh điều chúng ta có thể làm là chúng ta có thể tạo ra tất cả các pol đó  có cùng gốc nhưng module n mũ M và điều này dễ dàng hơn vì chúng ta có rất nhiều thủ thuật và sau này bạn sẽ thấy chúng ta có thể làm điều đó như thế nào nhưng về cơ bản chúng ta chỉ cần nhân với n mũ^ M hoặc chúng ta có thể nâng đa thức Pol của chúng ta lên lũy thừa M và những thứ tương tự và vì vậy, vấn đề của chúng ta bây giờ là tìm một đa thức có cùng nghiệm với bài toán của chúng ta nhưng modul n theo ^ M và có hệ số nhỏ sao cho chuẩn của poal mới này  được đề xuất bởi điều này và sau đó chúng ta biết rằng chúng ta có thể tìm ra nghiệm của các số nguyên, vậy làm thế nào để chúng ta kết hợp các đa thức đó lại

10
00:10:39,279 --> 00:11:59,240
với nhau như trong đó Kỹ thuật rút gọn mà chúng ta vừa thấy cho các latex rất rất rất hữu ích vì vậy kỹ thuật tuyệt vời này đi kèm với hai  những thứ mà chúng ta quan tâm, nó chỉ thực hiện phép toán tuyến tính số nguyên như tôi đã nói trước đây nếu bạn đưa ra cơ sở thì nó sẽ thay đổi cơ sở nhưng nó vẫn giữ nguyên ltis và đó là bởi vì nó chỉ thực hiện các phép toán tuyến tính số nguyên và nếu bạn thực hiện các phép toán tuyến tính số nguyên trên pols bạn giữ gốc bạn bảo tồn gốc điều thứ hai tốt cho chúng tôi là lll L cung cấp cho chúng tôi các vectơ ngắn ngắn hơn và đặc biệt là một vectơ mà chúng tôi sẽ gọi là Vector ngắn nhất của cơ sở mới uh và nếu bạn nhớ uh chúng tôi có  giới hạn trên của tất cả các vectơ mới của cơ sở mới mà tôi sẽ tìm thấy và đặc biệt là trên Vector đầu tiên đó ở đây vì vậy tôi đã không nói với bạn trước đó cách thực hiện điều này. cách tạo tất cả các pol có cùng gốc với chúng tôi  vấn đề nhưng modu n với^ M vì vậy đây là cách làm lại nếu bạn muốn biết chính xác tại

11
00:11:59,240 --> 00:13:18,079
sao họ có cùng một tuyến đường nhưng mô-đun n đến^ M bạn có thể tạm dừng video Tôi sẽ chỉ giải thích những gì họ đạt được uh  đầu tiên để họ có cùng Căn gốc nhưng họ cũng giới thiệu một đơn thức mới, mỗi lần lặp của chuỗi đa thức này sẽ giới thiệu một đơn thức mới và vì vậy điều này rất rất hữu ích vì khi chúng ta chèn tất cả đa thức vào Ma trận đại diện cho cơ sở  của L nó sẽ cho chúng ta một Ma trận tam giác và biết nếu chúng ta muốn biết định thức của ma trận đó thì nó chỉ là tích của tất cả các số hạng của đường chéo bên phải và như chúng ta đã thấy trước khi định thức là các phần quan trọng của giới hạn trên của Vector ngắn nhất của chúng ta sau L LM vì vậy hãy quay lại sơ đồ của chúng ta để có được bài toán đúng F và chúng ta đang cố gắng tìm các nghiệm modu n và để làm được điều đó chúng ta đang cố gắng tìm một đa thức khác có cùng điểm chung  Các nghiệm nhưng mô đun n the^ m và nếu đa thức đó tuân theo điểm thứ hai của một hogra gr bất đẳng thức này thì chúng ta có thể tìm nghiệm

12
00:13:18,079 --> 00:14:41,240
trên các số nguyên được rồi và chúng ta nói rằng chúng ta có thể làm điều đó bằng cách kết hợp nhiều pol uh vậy đó là cái mới của chúng ta  sơ đồ được rồi và thật nhanh chóng, chúng ta tạo ra một loạt các đa thức có cùng nghiệm với bài toán F của chúng ta nhưng theo modulo n với^ M, chúng ta tạo ra một ma trận với tất cả các phép toán đó sẽ là cơ sở của ltis của chúng ta, chúng ta đưa cơ sở đó cho L  nó mang lại cho chúng ta một cơ sở mới và Vector ngắn nhất thực ra là Bing Mill mà chúng ta đang tìm kiếm nhưng nếu bạn nhìn kỹ vào sơ đồ, bạn có thể thấy rằng chúng ta đang điều chỉnh nó giống như các hàm của X nhân với X lớn của chúng ta là  giới hạn trên của Rễ của chúng ta vậy tại sao vậy để tôi giải thích hãy nhớ thuộc tính của L chúng ta biết rằng cơ sở mới sau L sẽ có một Vector ngắn nhất sẽ bị giới hạn trên bởi định thức và một số số đúng, chúng ta biết điều đó và chúng ta cũng vậy  muốn tìm một đa thức mới tuân theo công thức đó điểm thứ hai của định lý HRA GRS làm thế nào để chúng ta kết hợp cả hai cái đó tốt hãy giả sử

13
00:14:41,240 --> 00:16:13,800
rằng đa thức mà chúng ta đang tìm kiếm thực sự là vectơ ngắn nhất và đó là tất cả những gì chúng ta phải làm  vì vậy nếu chúng ta nhìn lại sơ đồ của mình thay vì cho nó đa thức, chúng ta sẽ cho nó một đa thức mới giống như đa thức tổng hợp với giới hạn trên của các nghiệm để sẽ cho chúng ta một đa thức như vậy và khi chúng ta có loại a  đã chuyển poal, thực sự rất dễ dàng để chuyển đổi nó trở lại chỉ g g của X được rồi tuyệt vời chúng tôi biết cách thực hiện Ma trận của mình, chúng tôi biết cách thực hiện mọi thứ uh nhưng với giá trị nào của X cho loại gốc nào và M đó là gì  chúng tôi sử dụng trong thuật toán của mình để làm được điều đó chúng tôi phải hiểu rằng từ hai bất đẳng thức đó, Copper Smith đã tìm ra rằng định thức bị giới hạn bởi công thức này mà bạn có thể đơn giản hóa thành công thức này vì một số số hạng không đáng kể so với n và sau đó bạn  có một định lý nói chính xác giá trị nào của M với giá trị nào của uh n và thứ nguyên của Ma trận của chúng ta và giá trị nào của x lớn X

14
00:16:13,800 --> 00:17:30,640
thì với loại căn bậc ba nào, chúng ta có phương pháp này và chúng ta có thể tìm thấy gốc uh điều này còn hơn thế nữa ceramus đưa ra một loại định lý tổng quát hơn mà bạn có thể thấy anh ấy sử dụng uh b làm modulo trong đa thức khi B siêu lớn hơn uh n nâng rais lên lũy thừa Beta Và điều này là do bạn có thể áp dụng  kỹ thuật này ngay cả khi bạn không biết mô-đun và điều này cho phép chúng tôi tấn công RSA dưới các góc độ khác nhau, chẳng hạn như nếu bạn có xấp xỉ một trên số nguyên tố thì bạn có thể làm được, bạn có thể chuyển vấn đề đó thành mô-đun đa thức một trong số Prime và  nếu bạn không biết số nguyên tố đó thì không vấn đề gì vì bạn vẫn có thể sử dụng thuật toán đó nhưng tôi sẽ không giải thích điều đó trong video đó. Nếu bạn quan tâm, bạn có thể xem các bài viết khác nhau mà tôi sẽ liên kết dưới video đó sau này vào năm 2000, Bunny và Dery đã phát hiện ra một cuộc tấn công vào RSA bằng cách sử dụng một cuộc tấn công giống như Coer Smith nên chúng ta đã thấy định lý Coer Smith là một

15
00:17:30,640 --> 00:18:55,640
kỹ thuật để tìm các nghiệm nhỏ của một số modulo đa thức n và coper Smith cũng đưa ra lý thuyết của cô ấy nên nó không phải là một định lý  chứng minh bất cứ điều gì nhưng anh ấy đã đưa ra một kỹ thuật chung để tấn công đa thức với nhiều ẩn số và Bunny và dery đã sử dụng kỹ thuật đó trên P variat pols để tấn công RSA vì vậy hãy xem bây giờ nó sẽ thú vị hơn như thế nào vì chúng ta sẽ thấy một hoàn toàn bị hỏng nên chúng tôi đang cố gắng tìm khóa riêng từ khóa chung vì vậy nếu bạn nhớ tạo khóa riêng và khóa chung được liên kết với nhau, chúng tôi cần trước tiên tạo hai số nguyên tố p và Q đúng và RSA hoạt động vì bạn  có phương trình này bạn có e và D Mô-đun nghịch đảo lẫn nhau Theo hàm đúng Hàm ERS nếu bạn không biết tại sao tôi khuyên bạn nên kiểm tra Wikipedia và một số Lý thuyết nhóm. Nó khá dễ dàng để truy cập và nó cho phép bạn hiểu rất nhiều về toán học  đằng sau RSA, vì vậy bạn chuyển đổi nó thành số nguyên và bạn loại bỏ các phần riêng tư uh bằng cách đặt mô-đun phương trình E số mũ công khai và sau đó bạn có

16
00:18:55,640 --> 00:20:13,280
phương trình này có hai ẩn số nên ở đây K có thể là X và trừ P trừ Q có thể là Y  và đó là hai ẩn số của chúng ta và chúng ta có đa thức và chúng ta đang cố gắng tìm nghiệm modulo e được nên chúng ta chỉ chuyển đổi vấn đề của mình thành một đa thức với annun và nếu tôi tìm thấy liệu chúng ta có tìm thấy nghiệm của modu đa thức E thì  chúng ta tìm thấy khóa riêng, điều quan trọng là phải xem để hiểu chính xác cách chúng ta chuyển đổi dạng bài toán thành đa thức đó. Biết rằng kỹ thuật mà chúng ta sắp xem là tìm nghiệm của đa thức a b Vari một cách hiệu quả khi nó modulo một số nào đó và nếu  bạn muốn hiểu cách chúng tôi chuyển đổi vấn đề đó thành đa thức đó, hãy tạm dừng video và xem qua nó. Điều khá thú vị với Copper Smith là chúng ta có thể sử dụng định lý chính xác này cho phân cực có răng nên ở đây bạn có HRA gr cho phân cực có chính xác  điều tương tự ngoại trừ nó không phải là modulo n lũy thừa M lần này nó là modul e ra lũy thừa M và chúng ta có giới hạn trên của căn X và giới hạn trên dưới gốc

17
00:20:13,280 --> 00:21:34,720
y được rồi vì vậy về cơ bản chúng ta có thể sử dụng kỹ thuật tương tự như  trước đó với thời điểm này là đa thức VAR ngoại trừ việc ở cuối khi chúng ta tìm thấy G mới có gốc trên các số nguyên, chúng ta gặp vấn đề, hãy tưởng tượng một PO như xal y bạn có thể có vô số giải pháp vô hạn và đó là lý do tại sao như vậy  pols bạn cần ít nhất hai đa thức độc lập để có thể tìm ra nghiệm và cách tìm tốt hai polin đó nếu bạn nhớ tính chất của lll chúng ta có giới hạn trên cho tất cả các vectơ mới của cơ sở, các cơ sở mới và chúng ta chỉ cần lấy  hai vectơ ngắn nhất và sơ đồ của chúng tôi trở thành sơ đồ này trong đó chúng tôi chỉ sử dụng hai vectơ ngắn nhất, chúng tôi biến đổi chúng trở lại thành G1 và G2 và chúng tôi có thể sử dụng thuật toán kết quả để tìm nghiệm trên các số nguyên hoặc chúng tôi cũng có thể sử dụng cơ sở lấy ner  ừ, tôi sẽ không giải thích điều đó trong video đó nên nếu bạn muốn biết chính xác cách thức hoạt động, bạn có thể tự mình tìm kiếm để với kỹ thuật này, bạn tính toán các giới hạn như trước đó và

18
00:21:34,720 --> 00:23:00,000
bạn đạt đến điểm mà bạn biết mình có thể làm được  cái này bạn có thể tìm thấy khóa riêng nếu khóa riêng nhỏ hơn n được nâng lên lũy thừa 0,28 được rồi, bạn có giới hạn về khóa riêng và bạn biết rằng khóa riêng đủ nhỏ, chúng tôi có thể tìm thấy  kết quả và notor và dery tự hỏi liệu chúng ta có thể làm tốt hơn không và vâng, họ đồng ý vì nếu bạn nhìn vào Ma trận đó thì đó là Ma trận mà chúng ta sử dụng làm cơ sở cho ltis mà chúng ta sẽ cung cấp cho LL và đó là chuỗi đa thức trong hàng và chúng ta có thể thấy  rằng trong đường chéo, một số số hạng có hại, chúng quá lớn và chúng càng lớn thì định thức sẽ càng lớn và bóng trên trên Vector ngắn nhất của chúng ta sẽ càng tệ hơn. Hãy nhớ rằng chúng ta đang cố gắng nhỏ để tìm một đa thức mới với  các hệ số ngắn nên với một đoạn ngắn có Norm nhỏ để chúng ta có thể tìm nghiệm của các số nguyên nên chúng ta phải tìm định thức nhỏ nhất có thể để nó hoạt động trên Ma trận này và hai pol ở đây đang làm hỏng định thức, vậy tại sao không loại bỏ chúng

19
00:23:00,000 --> 00:24:25,840
vậy  chúng ta loại bỏ chúng và bây giờ chúng ta có Ma trận hình chữ nhật và do đó chúng ta không thể tính định thức và biết rằng sẽ rất khó để biết chính xác giới hạn trên của hai vectơ mới của cơ sở mới và bnny dery đã làm điều đó bằng cách phát minh ra  khái niệm về ma trận lũy tiến về mặt hình học nhưng điều này hơi phức tạp và đầy hy vọng, may mắn thay, Herman và May sau một vài năm đã tìm ra một kỹ thuật để tránh tất cả sự phức tạp này với Ma trận hình chữ nhật mà họ gọi đó là sự tuyến tính hóa tuyến tính không được giải và nó chỉ là một sự thay thế  bạn lấy pol của bạn à vấn đề của bạn và bạn thay thế 1 + x MTI thành Y bằng U và bạn làm điều đó trong tất cả các pol bạn tạo ra và nó mang lại cho bạn một Ma trận mới một cơ sở mới với sự thay thế và thực ra là Ma trận Ma trận mới có hình tam giác và điều đó thật tuyệt vời vì chúng ta biết có thể tính định thức một cách dễ dàng và thực sự thực hiện phép thay thế ở đây ngay từ đầu, chúng ta có thể thực hiện phép thay thế trở lại khi chúng ta hoàn thành

20
00:24:25,840 --> 00:25:50,240
bài toán và nó không thay đổi bất cứ điều gì nó chỉ thay đổi Ma trận của chúng ta và chúng ta  có thể tính định thức và chúng ta có thể tính giới hạn dễ dàng hơn và chắc chắn đã phát hiện ra rằng bằng cách làm điều đó bằng cách loại bỏ đa thức có hại khỏi danh sách pol, chúng ta có thể tìm thấy khóa riêng nếu khóa riêng nhỏ hơn n được nâng lên^ 0292  và đó được gọi là ràng buộc Bonet và Fey nên cá nhân tôi đã cắt hai cuộc tấn công coer tấn công SMI và cuộc tấn công Bunny và dery vì vậy nếu bạn muốn tìm hiểu sâu hơn về vấn đề này và muốn hiểu rõ hơn, bạn có thể truy cập GitHub và bạn có thể tìm thấy của tôi  repo uh và bạn có thể thử sử dụng và bạn có thể thử đọc mã và có thể điều đó sẽ giúp bạn thêm một chút uh chỉ là kết quả mang tính thông tin đồng Smith khá nhanh mang lại kết quả tốt mỗi khi nó là một định lý nên tôi biết mỗi lần nó sẽ như vậy  công việc và tôi chưa bao giờ mất nhiều hơn một giây bất kể kích thước để tìm ra kết quả Bunny và dery phức tạp hơn nên ở đây Delta là ừm nên Delta nằm trong công thức n đến

21
00:25:50,240 --> 00:27:26,960
the^ Delta được cho là lớn hơn  khóa riêng của chúng tôi và nếu  ví dụ: số mũ riêng  nhỏ hơn n tăng lũy ​​thừa 0,27 thì chúng tôi mất khoảng 2 phút để tìm  giải pháp nếu chúng tôi lớn hơn thế nếu khóa riêng của chúng tôi lớn hơn số đó thì sẽ mất nhiều thời gian hơn và tôi đã không làm như vậy có đủ thời gian với chiếc máy nhỏ của tôi để mang lại bất kỳ kết quả tốt nào vì vậy điều này là do khi bạn có giá trị lớn hơn cho khóa riêng tư, bạn phải tăng kích thước của ltis và độ phức tạp của thuật toán bị chi phối bởi độ phức tạp  của llll nên latis càng lớn thì sẽ càng mất nhiều thời gian để tính cơ sở mới nên về mặt lý thuyết chúng ta có thể tính khóa riêng cho các khóa riêng lớn hơn nhưng phải mất một thời gian dài nên Bon và Dery đã đi đến kết luận với kết quả đó  là 0,292 nhưng họ nghĩ đó là một kết quả không tự nhiên và họ nghĩ rằng bạn có thể tìm ra kết quả tốt hơn nhưng trong 15 năm không ai tìm thấy kết quả như vậy và thực ra ừ một nhóm các nhà nghiên cứu Trung Quốc ừ tại T Tina uh

22
00:27:26,960 --> 00:28:39,519
Đại học Bắc Kinh đã tìm thấy điều đó và tôi  không biết tờ giấy đó có hợp pháp không. Tôi chưa thực sự xem xét nó nhưng có vẻ như giới hạn đã được tính toán sai và bạn không thể tìm thấy khóa riêng cho một số lượng lớn như vậy nếu bạn muốn tìm khóa riêng lớn và kỹ thuật này cũng đang được sử dụng mất nhiều thời gian những gì bạn có thể làm là bạn có thể thực hiện cuộc tấn công của chú thỏ với giá trị D nhỏ và nếu nó không tìm thấy bất kỳ kết quả nào thì bạn biết nó lớn hơn và bạn có thể thử thực hiện tìm kiếm toàn diện bằng Brute Force để tìm  giá trị của  khóa riêng nên bây giờ là phần cuối của video của tôi. Tôi hy vọng bạn hiểu mọi thứ. Đây chỉ là video thứ hai của tôi cố gắng giải thích một bài viết trong video này thực tế là nhiều bài viết và tôi sẽ nói rõ hơn trong các video tiếp theo và tôi hy vọng  uh bạn có thể hiểu rõ hơn về hai cuộc tấn công đó nhờ có tôi nhờ video đó, vì vậy hãy theo dõi nhiều video hơn và bạn cũng có thể kiểm tra blog của tôi trong các liên kết bên dưới video đó, cảm ơn các bạn,

